<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Common Go channel uses | Derek&#39;s Hub</title>
<meta name="keywords" content="">
<meta name="description" content="Go is known for its native support for concurrency. You can easily spin up a concurrent execution (i.e. goroutine) using keyword go.
It is similar to OS thread but managed by Go runtime scheduler instead of OS kernel. The underlying implementation actually employs an M:N model to multiplex M goroutines onto N threads.
With the great power of concurrency comes with the responsibility to handle synchronisation in the right manner.">
<meta name="author" content="">
<link rel="canonical" href="https://derek-hardy.github.io/posts/go-channel/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.31a038ca4fe29d231a9edae8087cf7ea016d84e6abeb8663f248bda38b0d511b.css" integrity="sha256-MaA4yk/inSMantroCHz36gFthOar64Zj8ki9o4sNURs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://derek-hardy.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://derek-hardy.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://derek-hardy.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://derek-hardy.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://derek-hardy.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://derek-hardy.github.io/posts/go-channel/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://derek-hardy.github.io/posts/go-channel/">
  <meta property="og:site_name" content="Derek&#39;s Hub">
  <meta property="og:title" content="Common Go channel uses">
  <meta property="og:description" content="Go is known for its native support for concurrency. You can easily spin up a concurrent execution (i.e. goroutine) using keyword go.
It is similar to OS thread but managed by Go runtime scheduler instead of OS kernel. The underlying implementation actually employs an M:N model to multiplex M goroutines onto N threads.
With the great power of concurrency comes with the responsibility to handle synchronisation in the right manner.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-01T11:17:04+08:00">
    <meta property="article:modified_time" content="2023-12-01T11:17:04+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Common Go channel uses">
<meta name="twitter:description" content="Go is known for its native support for concurrency. You can easily spin up a concurrent execution (i.e. goroutine) using keyword go.
It is similar to OS thread but managed by Go runtime scheduler instead of OS kernel. The underlying implementation actually employs an M:N model to multiplex M goroutines onto N threads.
With the great power of concurrency comes with the responsibility to handle synchronisation in the right manner.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://derek-hardy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Common Go channel uses",
      "item": "https://derek-hardy.github.io/posts/go-channel/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Common Go channel uses",
  "name": "Common Go channel uses",
  "description": "Go is known for its native support for concurrency. You can easily spin up a concurrent execution (i.e. goroutine) using keyword go.\nIt is similar to OS thread but managed by Go runtime scheduler instead of OS kernel. The underlying implementation actually employs an M:N model to multiplex M goroutines onto N threads.\nWith the great power of concurrency comes with the responsibility to handle synchronisation in the right manner.\n",
  "keywords": [
    
  ],
  "articleBody": "Go is known for its native support for concurrency. You can easily spin up a concurrent execution (i.e. goroutine) using keyword go.\nIt is similar to OS thread but managed by Go runtime scheduler instead of OS kernel. The underlying implementation actually employs an M:N model to multiplex M goroutines onto N threads.\nWith the great power of concurrency comes with the responsibility to handle synchronisation in the right manner.\nIn Go, we can pass messages between different thread of executions using channel.\nUsed as signal Think of sending signals (kill -s signal pid) in the OS inter-process communication:\n// create an unbuffered channel done := make(chan int) // create a parallel execution path to start up a long-running service go func() { server.run() // once the server exits, it synchronises the termination to other threads of execution // by passing a signal to the channel done \u003c- 1 }() // the execution blocks here until a signal is received from the channel \u003c-done Used as message queue The typical producer-consumer pattern can be implemented with Channel.\n// create a buffered channel with size 10; in this case, producer can keep adding messages to the channel // without having to wait for receiver to receive (until the channel capacity is reached). // In the unbuffered case, sender blocks for every message until the receiver has received it. queue := make(chan string, 10) // start the producer goroutine go func() { messages := []string{\"order-1\", \"order-2\", \"order-3\"} for _, msg := range messages { queue \u003c- msg // send message to the channel } close(queue) // done with producing messages }() // the main goroutine acts as the consumer for msg := range queue { fmt.Println(\"Received: %s\", msg) } There is one more builtin call I didn’t mention in the previous post on Go Builtins. That is theclose()call\nYou can think of it as the TCP flagFINto indicate that sender has no more data to send and thus the communication channel should shut down.\nIf the channel is not closed in the above example, therangeloop will block and wait for a value, but loop terminates whenclose()is called on thequeuechannel.\nThe Go doc explains it in more details:\nThe close built-in function closes a channel. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element.\nUsed for timeout Channel also comes in handy when you want to enforce timeout for some functions. Think of timer interrupt in the OS used to switch context and execute scheduling decision.\ntime.After() already provided a convenient interface for this:\nfor { // the 'select' will choose the first case that unblocks; otherwise it blocks select { case m := \u003c-orderQueue: fmt.Printf(\"New order: %s\\n\", m) // wait for maximum 1 minute before moving on case t := \u003c-time.After(1 * time.Minute): fmt.Println(t.Format(time.RFC850)) // Friday, 01-Dec-23 12:16:56 +08 fmt.Println(\"Time out: no order received\") } } ",
  "wordCount" : "520",
  "inLanguage": "en",
  "datePublished": "2023-12-01T11:17:04+08:00",
  "dateModified": "2023-12-01T11:17:04+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://derek-hardy.github.io/posts/go-channel/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Derek's Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://derek-hardy.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://derek-hardy.github.io/" accesskey="h" title="Derek&#39;s Hub (Alt + H)">Derek&#39;s Hub</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://derek-hardy.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://derek-hardy.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://derek-hardy.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://derek-hardy.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Common Go channel uses
    </h1>
    <div class="post-meta"><span title='2023-12-01 11:17:04 +0800 +08'>December 1, 2023</span>&nbsp;·&nbsp;3 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#used-as-signal" aria-label="Used as signal">Used as signal</a></li>
                <li>
                    <a href="#used-as-message-queue" aria-label="Used as message queue">Used as message queue</a></li>
                <li>
                    <a href="#used-for-timeout" aria-label="Used for timeout">Used for timeout</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Go is known for its native support for concurrency. You can easily spin up a concurrent execution (i.e. goroutine) using keyword <code>go</code>.</p>
<p>It is similar to OS thread but managed by Go runtime scheduler instead of OS kernel. The underlying implementation actually employs an M:N model to multiplex M goroutines onto N threads.</p>
<p>With the great power of concurrency comes with the responsibility to handle synchronisation in the right manner.</p>
<p>In Go, we can pass messages between different thread of executions using <em>channel</em>.</p>
<h3 id="used-as-signal">Used as signal<a hidden class="anchor" aria-hidden="true" href="#used-as-signal">#</a></h3>
<p>Think of sending signals (<code>kill -s signal pid</code>) in the OS inter-process communication:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// create an unbuffered channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// create a parallel execution path to start up a long-running service
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">run</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// once the server exits, it synchronises the termination to other threads of execution 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// by passing a signal to the channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the execution blocks here until a signal is received from the channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
</span></span></code></pre></div><h3 id="used-as-message-queue">Used as message queue<a hidden class="anchor" aria-hidden="true" href="#used-as-message-queue">#</a></h3>
<p>The typical producer-consumer pattern can be implemented with Channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// create a buffered channel with size 10; in this case, producer can keep adding messages to the channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// without having to wait for receiver to receive (until the channel capacity is reached).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// In the unbuffered case, sender blocks for every message until the receiver has received it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// start the producer goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">messages</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;order-1&#34;</span>, <span style="color:#e6db74">&#34;order-2&#34;</span>, <span style="color:#e6db74">&#34;order-3&#34;</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">messages</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">queue</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">msg</span> <span style="color:#75715e">// send message to the channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">queue</span>) <span style="color:#75715e">// done with producing messages
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// the main goroutine acts as the consumer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">queue</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Received: %s&#34;</span>, <span style="color:#a6e22e">msg</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There is one more builtin call I didn&rsquo;t mention in the previous post on <a href="../go-built-in/">Go Builtins</a>.
That is the<code>close()</code>call</p>
<p>You can think of it as the TCP flag<code>FIN</code>to indicate that sender has no more data to send and thus the communication channel should shut down.</p>
<p>If the channel is not closed in the above example, the<code>range</code>loop will block and wait for a value, but loop terminates when<code>close()</code>is called on the<code>queue</code>channel.</p>
<p>The Go doc explains it in more details:</p>
<blockquote>
<p>The close built-in function closes a channel. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element.</p>
</blockquote>
<h3 id="used-for-timeout">Used for timeout<a hidden class="anchor" aria-hidden="true" href="#used-for-timeout">#</a></h3>
<p>Channel also comes in handy when you want to enforce timeout for some functions.
Think of <em>timer interrupt</em> in the OS used to switch context and execute scheduling decision.</p>
<p><code>time.After()</code> already provided a convenient interface for this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// the &#39;select&#39; will choose the first case that unblocks; otherwise it blocks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">orderQueue</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;New order: %s\n&#34;</span>, <span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// wait for maximum 1 minute before moving on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Minute</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Format</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">RFC850</span>)) <span style="color:#75715e">// Friday, 01-Dec-23 12:16:56 +08
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Time out: no order received&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://derek-hardy.github.io/posts/data-structure-1/">
    <span class="title">« Prev</span>
    <br>
    <span>Data Structure in Go - Part 1</span>
  </a>
  <a class="next" href="https://derek-hardy.github.io/posts/go-built-in/">
    <span class="title">Next »</span>
    <br>
    <span>Built-in functions in Go</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
